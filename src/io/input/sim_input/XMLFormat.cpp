// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "XMLFormat.h"

// dvector_t
// 

const dvector_t::X_type& dvector_t::
X () const
{
  return this->X_.get ();
}

dvector_t::X_type& dvector_t::
X ()
{
  return this->X_.get ();
}

void dvector_t::
X (const X_type& x)
{
  this->X_.set (x);
}

const dvector_t::Y_type& dvector_t::
Y () const
{
  return this->Y_.get ();
}

dvector_t::Y_type& dvector_t::
Y ()
{
  return this->Y_.get ();
}

void dvector_t::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const dvector_t::Z_type& dvector_t::
Z () const
{
  return this->Z_.get ();
}

dvector_t::Z_type& dvector_t::
Z ()
{
  return this->Z_.get ();
}

void dvector_t::
Z (const Z_type& x)
{
  this->Z_.set (x);
}


// ivector_t
// 

const ivector_t::X_type& ivector_t::
X () const
{
  return this->X_.get ();
}

ivector_t::X_type& ivector_t::
X ()
{
  return this->X_.get ();
}

void ivector_t::
X (const X_type& x)
{
  this->X_.set (x);
}

const ivector_t::Y_type& ivector_t::
Y () const
{
  return this->Y_.get ();
}

ivector_t::Y_type& ivector_t::
Y ()
{
  return this->Y_.get ();
}

void ivector_t::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

const ivector_t::Z_type& ivector_t::
Z () const
{
  return this->Z_.get ();
}

ivector_t::Z_type& ivector_t::
Z ()
{
  return this->Z_.get ();
}

void ivector_t::
Z (const Z_type& x)
{
  this->Z_.set (x);
}


// nonNegativeDouble_t
// 


// positiveDouble_t
// 


// posDVector_t
// 

const posDVector_t::X_type& posDVector_t::
X () const
{
  return this->X_.get ();
}

posDVector_t::X_type& posDVector_t::
X ()
{
  return this->X_.get ();
}

void posDVector_t::
X (const X_type& x)
{
  this->X_.set (x);
}

void posDVector_t::
X (::std::unique_ptr< X_type > x)
{
  this->X_.set (std::move (x));
}

const posDVector_t::Y_type& posDVector_t::
Y () const
{
  return this->Y_.get ();
}

posDVector_t::Y_type& posDVector_t::
Y ()
{
  return this->Y_.get ();
}

void posDVector_t::
Y (const Y_type& x)
{
  this->Y_.set (x);
}

void posDVector_t::
Y (::std::unique_ptr< Y_type > x)
{
  this->Y_.set (std::move (x));
}

const posDVector_t::Z_type& posDVector_t::
Z () const
{
  return this->Z_.get ();
}

posDVector_t::Z_type& posDVector_t::
Z ()
{
  return this->Z_.get ();
}

void posDVector_t::
Z (const Z_type& x)
{
  this->Z_.set (x);
}

void posDVector_t::
Z (::std::unique_ptr< Z_type > x)
{
  this->Z_.set (std::move (x));
}


// output_t
// 

const output_t::FolderPath_optional& output_t::
FolderPath () const
{
  return this->FolderPath_;
}

output_t::FolderPath_optional& output_t::
FolderPath ()
{
  return this->FolderPath_;
}

void output_t::
FolderPath (const FolderPath_type& x)
{
  this->FolderPath_.set (x);
}

void output_t::
FolderPath (const FolderPath_optional& x)
{
  this->FolderPath_ = x;
}

void output_t::
FolderPath (::std::unique_ptr< FolderPath_type > x)
{
  this->FolderPath_.set (std::move (x));
}

const output_t::OutputFileName_optional& output_t::
OutputFileName () const
{
  return this->OutputFileName_;
}

output_t::OutputFileName_optional& output_t::
OutputFileName ()
{
  return this->OutputFileName_;
}

void output_t::
OutputFileName (const OutputFileName_type& x)
{
  this->OutputFileName_.set (x);
}

void output_t::
OutputFileName (const OutputFileName_optional& x)
{
  this->OutputFileName_ = x;
}

void output_t::
OutputFileName (::std::unique_ptr< OutputFileName_type > x)
{
  this->OutputFileName_.set (std::move (x));
}


// outputWriter_t
// 

outputWriter_t::
outputWriter_t (value v)
: ::xml_schema::string (_xsd_outputWriter_t_literals_[v])
{
}

outputWriter_t::
outputWriter_t (const char* v)
: ::xml_schema::string (v)
{
}

outputWriter_t::
outputWriter_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

outputWriter_t::
outputWriter_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

outputWriter_t::
outputWriter_t (const outputWriter_t& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

outputWriter_t& outputWriter_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_outputWriter_t_literals_[v]);

  return *this;
}


// gravity_t
// 


// lennardJones_t
// 

const lennardJones_t::Epsilon_optional& lennardJones_t::
Epsilon () const
{
  return this->Epsilon_;
}

lennardJones_t::Epsilon_optional& lennardJones_t::
Epsilon ()
{
  return this->Epsilon_;
}

void lennardJones_t::
Epsilon (const Epsilon_type& x)
{
  this->Epsilon_.set (x);
}

void lennardJones_t::
Epsilon (const Epsilon_optional& x)
{
  this->Epsilon_ = x;
}

const lennardJones_t::Sigma_optional& lennardJones_t::
Sigma () const
{
  return this->Sigma_;
}

lennardJones_t::Sigma_optional& lennardJones_t::
Sigma ()
{
  return this->Sigma_;
}

void lennardJones_t::
Sigma (const Sigma_type& x)
{
  this->Sigma_.set (x);
}

void lennardJones_t::
Sigma (const Sigma_optional& x)
{
  this->Sigma_ = x;
}

void lennardJones_t::
Sigma (::std::unique_ptr< Sigma_type > x)
{
  this->Sigma_.set (std::move (x));
}


// forceCalculation_t
// 

const forceCalculation_t::Gravity_optional& forceCalculation_t::
Gravity () const
{
  return this->Gravity_;
}

forceCalculation_t::Gravity_optional& forceCalculation_t::
Gravity ()
{
  return this->Gravity_;
}

void forceCalculation_t::
Gravity (const Gravity_type& x)
{
  this->Gravity_.set (x);
}

void forceCalculation_t::
Gravity (const Gravity_optional& x)
{
  this->Gravity_ = x;
}

void forceCalculation_t::
Gravity (::std::unique_ptr< Gravity_type > x)
{
  this->Gravity_.set (std::move (x));
}

const forceCalculation_t::LennardJones_optional& forceCalculation_t::
LennardJones () const
{
  return this->LennardJones_;
}

forceCalculation_t::LennardJones_optional& forceCalculation_t::
LennardJones ()
{
  return this->LennardJones_;
}

void forceCalculation_t::
LennardJones (const LennardJones_type& x)
{
  this->LennardJones_.set (x);
}

void forceCalculation_t::
LennardJones (const LennardJones_optional& x)
{
  this->LennardJones_ = x;
}

void forceCalculation_t::
LennardJones (::std::unique_ptr< LennardJones_type > x)
{
  this->LennardJones_.set (std::move (x));
}


// positionCalculation_t
// 

positionCalculation_t::
positionCalculation_t (value v)
: ::xml_schema::string (_xsd_positionCalculation_t_literals_[v])
{
}

positionCalculation_t::
positionCalculation_t (const char* v)
: ::xml_schema::string (v)
{
}

positionCalculation_t::
positionCalculation_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

positionCalculation_t::
positionCalculation_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

positionCalculation_t::
positionCalculation_t (const positionCalculation_t& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

positionCalculation_t& positionCalculation_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_positionCalculation_t_literals_[v]);

  return *this;
}


// velocityCalculation_t
// 

velocityCalculation_t::
velocityCalculation_t (value v)
: ::xml_schema::string (_xsd_velocityCalculation_t_literals_[v])
{
}

velocityCalculation_t::
velocityCalculation_t (const char* v)
: ::xml_schema::string (v)
{
}

velocityCalculation_t::
velocityCalculation_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

velocityCalculation_t::
velocityCalculation_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

velocityCalculation_t::
velocityCalculation_t (const velocityCalculation_t& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

velocityCalculation_t& velocityCalculation_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_velocityCalculation_t_literals_[v]);

  return *this;
}


// boundaryBehavior_t
// 

boundaryBehavior_t::
boundaryBehavior_t (value v)
: ::xml_schema::string (_xsd_boundaryBehavior_t_literals_[v])
{
}

boundaryBehavior_t::
boundaryBehavior_t (const char* v)
: ::xml_schema::string (v)
{
}

boundaryBehavior_t::
boundaryBehavior_t (const ::std::string& v)
: ::xml_schema::string (v)
{
}

boundaryBehavior_t::
boundaryBehavior_t (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

boundaryBehavior_t::
boundaryBehavior_t (const boundaryBehavior_t& v,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

boundaryBehavior_t& boundaryBehavior_t::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_boundaryBehavior_t_literals_[v]);

  return *this;
}


// boundaries_t
// 

const boundaries_t::BoxSize_type& boundaries_t::
BoxSize () const
{
  return this->BoxSize_.get ();
}

boundaries_t::BoxSize_type& boundaries_t::
BoxSize ()
{
  return this->BoxSize_.get ();
}

void boundaries_t::
BoxSize (const BoxSize_type& x)
{
  this->BoxSize_.set (x);
}

void boundaries_t::
BoxSize (::std::unique_ptr< BoxSize_type > x)
{
  this->BoxSize_.set (std::move (x));
}

const boundaries_t::Front_type& boundaries_t::
Front () const
{
  return this->Front_.get ();
}

boundaries_t::Front_type& boundaries_t::
Front ()
{
  return this->Front_.get ();
}

void boundaries_t::
Front (const Front_type& x)
{
  this->Front_.set (x);
}

void boundaries_t::
Front (::std::unique_ptr< Front_type > x)
{
  this->Front_.set (std::move (x));
}

const boundaries_t::Rear_type& boundaries_t::
Rear () const
{
  return this->Rear_.get ();
}

boundaries_t::Rear_type& boundaries_t::
Rear ()
{
  return this->Rear_.get ();
}

void boundaries_t::
Rear (const Rear_type& x)
{
  this->Rear_.set (x);
}

void boundaries_t::
Rear (::std::unique_ptr< Rear_type > x)
{
  this->Rear_.set (std::move (x));
}

const boundaries_t::Left_type& boundaries_t::
Left () const
{
  return this->Left_.get ();
}

boundaries_t::Left_type& boundaries_t::
Left ()
{
  return this->Left_.get ();
}

void boundaries_t::
Left (const Left_type& x)
{
  this->Left_.set (x);
}

void boundaries_t::
Left (::std::unique_ptr< Left_type > x)
{
  this->Left_.set (std::move (x));
}

const boundaries_t::Right_type& boundaries_t::
Right () const
{
  return this->Right_.get ();
}

boundaries_t::Right_type& boundaries_t::
Right ()
{
  return this->Right_.get ();
}

void boundaries_t::
Right (const Right_type& x)
{
  this->Right_.set (x);
}

void boundaries_t::
Right (::std::unique_ptr< Right_type > x)
{
  this->Right_.set (std::move (x));
}

const boundaries_t::Top_type& boundaries_t::
Top () const
{
  return this->Top_.get ();
}

boundaries_t::Top_type& boundaries_t::
Top ()
{
  return this->Top_.get ();
}

void boundaries_t::
Top (const Top_type& x)
{
  this->Top_.set (x);
}

void boundaries_t::
Top (::std::unique_ptr< Top_type > x)
{
  this->Top_.set (std::move (x));
}

const boundaries_t::Bottom_type& boundaries_t::
Bottom () const
{
  return this->Bottom_.get ();
}

boundaries_t::Bottom_type& boundaries_t::
Bottom ()
{
  return this->Bottom_.get ();
}

void boundaries_t::
Bottom (const Bottom_type& x)
{
  this->Bottom_.set (x);
}

void boundaries_t::
Bottom (::std::unique_ptr< Bottom_type > x)
{
  this->Bottom_.set (std::move (x));
}


// linkedCell_t
// 

const linkedCell_t::BoundaryBox_type& linkedCell_t::
BoundaryBox () const
{
  return this->BoundaryBox_.get ();
}

linkedCell_t::BoundaryBox_type& linkedCell_t::
BoundaryBox ()
{
  return this->BoundaryBox_.get ();
}

void linkedCell_t::
BoundaryBox (const BoundaryBox_type& x)
{
  this->BoundaryBox_.set (x);
}

void linkedCell_t::
BoundaryBox (::std::unique_ptr< BoundaryBox_type > x)
{
  this->BoundaryBox_.set (std::move (x));
}

const linkedCell_t::CutoffRadius_type& linkedCell_t::
CutoffRadius () const
{
  return this->CutoffRadius_.get ();
}

linkedCell_t::CutoffRadius_type& linkedCell_t::
CutoffRadius ()
{
  return this->CutoffRadius_.get ();
}

void linkedCell_t::
CutoffRadius (const CutoffRadius_type& x)
{
  this->CutoffRadius_.set (x);
}

void linkedCell_t::
CutoffRadius (::std::unique_ptr< CutoffRadius_type > x)
{
  this->CutoffRadius_.set (std::move (x));
}


// naive_t
// 


// simulationStrategy_t
// 

const simulationStrategy_t::LinkedCell_optional& simulationStrategy_t::
LinkedCell () const
{
  return this->LinkedCell_;
}

simulationStrategy_t::LinkedCell_optional& simulationStrategy_t::
LinkedCell ()
{
  return this->LinkedCell_;
}

void simulationStrategy_t::
LinkedCell (const LinkedCell_type& x)
{
  this->LinkedCell_.set (x);
}

void simulationStrategy_t::
LinkedCell (const LinkedCell_optional& x)
{
  this->LinkedCell_ = x;
}

void simulationStrategy_t::
LinkedCell (::std::unique_ptr< LinkedCell_type > x)
{
  this->LinkedCell_.set (std::move (x));
}

const simulationStrategy_t::Naive_optional& simulationStrategy_t::
Naive () const
{
  return this->Naive_;
}

simulationStrategy_t::Naive_optional& simulationStrategy_t::
Naive ()
{
  return this->Naive_;
}

void simulationStrategy_t::
Naive (const Naive_type& x)
{
  this->Naive_.set (x);
}

void simulationStrategy_t::
Naive (const Naive_optional& x)
{
  this->Naive_ = x;
}

void simulationStrategy_t::
Naive (::std::unique_ptr< Naive_type > x)
{
  this->Naive_.set (std::move (x));
}


// logLevel_t
// 


// fileBenchmark_t
// 


// defaultBenchmark_t
// 

const defaultBenchmark_t::MaximumBodySize_optional& defaultBenchmark_t::
MaximumBodySize () const
{
  return this->MaximumBodySize_;
}

defaultBenchmark_t::MaximumBodySize_optional& defaultBenchmark_t::
MaximumBodySize ()
{
  return this->MaximumBodySize_;
}

void defaultBenchmark_t::
MaximumBodySize (const MaximumBodySize_type& x)
{
  this->MaximumBodySize_.set (x);
}

void defaultBenchmark_t::
MaximumBodySize (const MaximumBodySize_optional& x)
{
  this->MaximumBodySize_ = x;
}


// benchmarkType_t
// 

const benchmarkType_t::FileBenchmark_optional& benchmarkType_t::
FileBenchmark () const
{
  return this->FileBenchmark_;
}

benchmarkType_t::FileBenchmark_optional& benchmarkType_t::
FileBenchmark ()
{
  return this->FileBenchmark_;
}

void benchmarkType_t::
FileBenchmark (const FileBenchmark_type& x)
{
  this->FileBenchmark_.set (x);
}

void benchmarkType_t::
FileBenchmark (const FileBenchmark_optional& x)
{
  this->FileBenchmark_ = x;
}

void benchmarkType_t::
FileBenchmark (::std::unique_ptr< FileBenchmark_type > x)
{
  this->FileBenchmark_.set (std::move (x));
}

const benchmarkType_t::DefaultBenchmark_optional& benchmarkType_t::
DefaultBenchmark () const
{
  return this->DefaultBenchmark_;
}

benchmarkType_t::DefaultBenchmark_optional& benchmarkType_t::
DefaultBenchmark ()
{
  return this->DefaultBenchmark_;
}

void benchmarkType_t::
DefaultBenchmark (const DefaultBenchmark_type& x)
{
  this->DefaultBenchmark_.set (x);
}

void benchmarkType_t::
DefaultBenchmark (const DefaultBenchmark_optional& x)
{
  this->DefaultBenchmark_ = x;
}

void benchmarkType_t::
DefaultBenchmark (::std::unique_ptr< DefaultBenchmark_type > x)
{
  this->DefaultBenchmark_.set (std::move (x));
}


// benchmark_t
// 

const benchmark_t::BenchmarkType_type& benchmark_t::
BenchmarkType () const
{
  return this->BenchmarkType_.get ();
}

benchmark_t::BenchmarkType_type& benchmark_t::
BenchmarkType ()
{
  return this->BenchmarkType_.get ();
}

void benchmark_t::
BenchmarkType (const BenchmarkType_type& x)
{
  this->BenchmarkType_.set (x);
}

void benchmark_t::
BenchmarkType (::std::unique_ptr< BenchmarkType_type > x)
{
  this->BenchmarkType_.set (std::move (x));
}

const benchmark_t::IterationCount_optional& benchmark_t::
IterationCount () const
{
  return this->IterationCount_;
}

benchmark_t::IterationCount_optional& benchmark_t::
IterationCount ()
{
  return this->IterationCount_;
}

void benchmark_t::
IterationCount (const IterationCount_type& x)
{
  this->IterationCount_.set (x);
}

void benchmark_t::
IterationCount (const IterationCount_optional& x)
{
  this->IterationCount_ = x;
}


// dimension_t
// 


// particle_t
// 

const particle_t::Position_type& particle_t::
Position () const
{
  return this->Position_.get ();
}

particle_t::Position_type& particle_t::
Position ()
{
  return this->Position_.get ();
}

void particle_t::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void particle_t::
Position (::std::unique_ptr< Position_type > x)
{
  this->Position_.set (std::move (x));
}

const particle_t::Velocity_type& particle_t::
Velocity () const
{
  return this->Velocity_.get ();
}

particle_t::Velocity_type& particle_t::
Velocity ()
{
  return this->Velocity_.get ();
}

void particle_t::
Velocity (const Velocity_type& x)
{
  this->Velocity_.set (x);
}

void particle_t::
Velocity (::std::unique_ptr< Velocity_type > x)
{
  this->Velocity_.set (std::move (x));
}

const particle_t::Mass_type& particle_t::
Mass () const
{
  return this->Mass_.get ();
}

particle_t::Mass_type& particle_t::
Mass ()
{
  return this->Mass_.get ();
}

void particle_t::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}


// cuboid_t
// 

const cuboid_t::Position_type& cuboid_t::
Position () const
{
  return this->Position_.get ();
}

cuboid_t::Position_type& cuboid_t::
Position ()
{
  return this->Position_.get ();
}

void cuboid_t::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void cuboid_t::
Position (::std::unique_ptr< Position_type > x)
{
  this->Position_.set (std::move (x));
}

const cuboid_t::Velocity_type& cuboid_t::
Velocity () const
{
  return this->Velocity_.get ();
}

cuboid_t::Velocity_type& cuboid_t::
Velocity ()
{
  return this->Velocity_.get ();
}

void cuboid_t::
Velocity (const Velocity_type& x)
{
  this->Velocity_.set (x);
}

void cuboid_t::
Velocity (::std::unique_ptr< Velocity_type > x)
{
  this->Velocity_.set (std::move (x));
}

const cuboid_t::Dimensions_type& cuboid_t::
Dimensions () const
{
  return this->Dimensions_.get ();
}

cuboid_t::Dimensions_type& cuboid_t::
Dimensions ()
{
  return this->Dimensions_.get ();
}

void cuboid_t::
Dimensions (const Dimensions_type& x)
{
  this->Dimensions_.set (x);
}

void cuboid_t::
Dimensions (::std::unique_ptr< Dimensions_type > x)
{
  this->Dimensions_.set (std::move (x));
}

const cuboid_t::Spacing_type& cuboid_t::
Spacing () const
{
  return this->Spacing_.get ();
}

cuboid_t::Spacing_type& cuboid_t::
Spacing ()
{
  return this->Spacing_.get ();
}

void cuboid_t::
Spacing (const Spacing_type& x)
{
  this->Spacing_.set (x);
}

const cuboid_t::Mass_type& cuboid_t::
Mass () const
{
  return this->Mass_.get ();
}

cuboid_t::Mass_type& cuboid_t::
Mass ()
{
  return this->Mass_.get ();
}

void cuboid_t::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}


// sphere_t
// 

const sphere_t::Position_type& sphere_t::
Position () const
{
  return this->Position_.get ();
}

sphere_t::Position_type& sphere_t::
Position ()
{
  return this->Position_.get ();
}

void sphere_t::
Position (const Position_type& x)
{
  this->Position_.set (x);
}

void sphere_t::
Position (::std::unique_ptr< Position_type > x)
{
  this->Position_.set (std::move (x));
}

const sphere_t::Velocity_type& sphere_t::
Velocity () const
{
  return this->Velocity_.get ();
}

sphere_t::Velocity_type& sphere_t::
Velocity ()
{
  return this->Velocity_.get ();
}

void sphere_t::
Velocity (const Velocity_type& x)
{
  this->Velocity_.set (x);
}

void sphere_t::
Velocity (::std::unique_ptr< Velocity_type > x)
{
  this->Velocity_.set (std::move (x));
}

const sphere_t::Radius_type& sphere_t::
Radius () const
{
  return this->Radius_.get ();
}

sphere_t::Radius_type& sphere_t::
Radius ()
{
  return this->Radius_.get ();
}

void sphere_t::
Radius (const Radius_type& x)
{
  this->Radius_.set (x);
}

const sphere_t::Spacing_type& sphere_t::
Spacing () const
{
  return this->Spacing_.get ();
}

sphere_t::Spacing_type& sphere_t::
Spacing ()
{
  return this->Spacing_.get ();
}

void sphere_t::
Spacing (const Spacing_type& x)
{
  this->Spacing_.set (x);
}

const sphere_t::Mass_type& sphere_t::
Mass () const
{
  return this->Mass_.get ();
}

sphere_t::Mass_type& sphere_t::
Mass ()
{
  return this->Mass_.get ();
}

void sphere_t::
Mass (const Mass_type& x)
{
  this->Mass_.set (x);
}


// shape_t
// 

const shape_t::Particle_optional& shape_t::
Particle () const
{
  return this->Particle_;
}

shape_t::Particle_optional& shape_t::
Particle ()
{
  return this->Particle_;
}

void shape_t::
Particle (const Particle_type& x)
{
  this->Particle_.set (x);
}

void shape_t::
Particle (const Particle_optional& x)
{
  this->Particle_ = x;
}

void shape_t::
Particle (::std::unique_ptr< Particle_type > x)
{
  this->Particle_.set (std::move (x));
}

const shape_t::Cuboid_optional& shape_t::
Cuboid () const
{
  return this->Cuboid_;
}

shape_t::Cuboid_optional& shape_t::
Cuboid ()
{
  return this->Cuboid_;
}

void shape_t::
Cuboid (const Cuboid_type& x)
{
  this->Cuboid_.set (x);
}

void shape_t::
Cuboid (const Cuboid_optional& x)
{
  this->Cuboid_ = x;
}

void shape_t::
Cuboid (::std::unique_ptr< Cuboid_type > x)
{
  this->Cuboid_.set (std::move (x));
}

const shape_t::Sphere_optional& shape_t::
Sphere () const
{
  return this->Sphere_;
}

shape_t::Sphere_optional& shape_t::
Sphere ()
{
  return this->Sphere_;
}

void shape_t::
Sphere (const Sphere_type& x)
{
  this->Sphere_.set (x);
}

void shape_t::
Sphere (const Sphere_optional& x)
{
  this->Sphere_ = x;
}

void shape_t::
Sphere (::std::unique_ptr< Sphere_type > x)
{
  this->Sphere_.set (std::move (x));
}


// shapeList_t
// 

const shapeList_t::Shape_sequence& shapeList_t::
Shape () const
{
  return this->Shape_;
}

shapeList_t::Shape_sequence& shapeList_t::
Shape ()
{
  return this->Shape_;
}

void shapeList_t::
Shape (const Shape_sequence& s)
{
  this->Shape_ = s;
}


// simulation_t
// 

const simulation_t::OutputFile_optional& simulation_t::
OutputFile () const
{
  return this->OutputFile_;
}

simulation_t::OutputFile_optional& simulation_t::
OutputFile ()
{
  return this->OutputFile_;
}

void simulation_t::
OutputFile (const OutputFile_type& x)
{
  this->OutputFile_.set (x);
}

void simulation_t::
OutputFile (const OutputFile_optional& x)
{
  this->OutputFile_ = x;
}

void simulation_t::
OutputFile (::std::unique_ptr< OutputFile_type > x)
{
  this->OutputFile_.set (std::move (x));
}

const simulation_t::StartTime_optional& simulation_t::
StartTime () const
{
  return this->StartTime_;
}

simulation_t::StartTime_optional& simulation_t::
StartTime ()
{
  return this->StartTime_;
}

void simulation_t::
StartTime (const StartTime_type& x)
{
  this->StartTime_.set (x);
}

void simulation_t::
StartTime (const StartTime_optional& x)
{
  this->StartTime_ = x;
}

const simulation_t::EndTime_optional& simulation_t::
EndTime () const
{
  return this->EndTime_;
}

simulation_t::EndTime_optional& simulation_t::
EndTime ()
{
  return this->EndTime_;
}

void simulation_t::
EndTime (const EndTime_type& x)
{
  this->EndTime_.set (x);
}

void simulation_t::
EndTime (const EndTime_optional& x)
{
  this->EndTime_ = x;
}

const simulation_t::TimeStepSize_optional& simulation_t::
TimeStepSize () const
{
  return this->TimeStepSize_;
}

simulation_t::TimeStepSize_optional& simulation_t::
TimeStepSize ()
{
  return this->TimeStepSize_;
}

void simulation_t::
TimeStepSize (const TimeStepSize_type& x)
{
  this->TimeStepSize_.set (x);
}

void simulation_t::
TimeStepSize (const TimeStepSize_optional& x)
{
  this->TimeStepSize_ = x;
}

void simulation_t::
TimeStepSize (::std::unique_ptr< TimeStepSize_type > x)
{
  this->TimeStepSize_.set (std::move (x));
}

const simulation_t::ForceCalculation_type& simulation_t::
ForceCalculation () const
{
  return this->ForceCalculation_.get ();
}

simulation_t::ForceCalculation_type& simulation_t::
ForceCalculation ()
{
  return this->ForceCalculation_.get ();
}

void simulation_t::
ForceCalculation (const ForceCalculation_type& x)
{
  this->ForceCalculation_.set (x);
}

void simulation_t::
ForceCalculation (::std::unique_ptr< ForceCalculation_type > x)
{
  this->ForceCalculation_.set (std::move (x));
}

const simulation_t::PositionCalculation_optional& simulation_t::
PositionCalculation () const
{
  return this->PositionCalculation_;
}

simulation_t::PositionCalculation_optional& simulation_t::
PositionCalculation ()
{
  return this->PositionCalculation_;
}

void simulation_t::
PositionCalculation (const PositionCalculation_type& x)
{
  this->PositionCalculation_.set (x);
}

void simulation_t::
PositionCalculation (const PositionCalculation_optional& x)
{
  this->PositionCalculation_ = x;
}

void simulation_t::
PositionCalculation (::std::unique_ptr< PositionCalculation_type > x)
{
  this->PositionCalculation_.set (std::move (x));
}

const simulation_t::VelocityCalculation_optional& simulation_t::
VelocityCalculation () const
{
  return this->VelocityCalculation_;
}

simulation_t::VelocityCalculation_optional& simulation_t::
VelocityCalculation ()
{
  return this->VelocityCalculation_;
}

void simulation_t::
VelocityCalculation (const VelocityCalculation_type& x)
{
  this->VelocityCalculation_.set (x);
}

void simulation_t::
VelocityCalculation (const VelocityCalculation_optional& x)
{
  this->VelocityCalculation_ = x;
}

void simulation_t::
VelocityCalculation (::std::unique_ptr< VelocityCalculation_type > x)
{
  this->VelocityCalculation_.set (std::move (x));
}

const simulation_t::AverageBrownianMotion_optional& simulation_t::
AverageBrownianMotion () const
{
  return this->AverageBrownianMotion_;
}

simulation_t::AverageBrownianMotion_optional& simulation_t::
AverageBrownianMotion ()
{
  return this->AverageBrownianMotion_;
}

void simulation_t::
AverageBrownianMotion (const AverageBrownianMotion_type& x)
{
  this->AverageBrownianMotion_.set (x);
}

void simulation_t::
AverageBrownianMotion (const AverageBrownianMotion_optional& x)
{
  this->AverageBrownianMotion_ = x;
}

void simulation_t::
AverageBrownianMotion (::std::unique_ptr< AverageBrownianMotion_type > x)
{
  this->AverageBrownianMotion_.set (std::move (x));
}

const simulation_t::SimulationStrategy_type& simulation_t::
SimulationStrategy () const
{
  return this->SimulationStrategy_.get ();
}

simulation_t::SimulationStrategy_type& simulation_t::
SimulationStrategy ()
{
  return this->SimulationStrategy_.get ();
}

void simulation_t::
SimulationStrategy (const SimulationStrategy_type& x)
{
  this->SimulationStrategy_.set (x);
}

void simulation_t::
SimulationStrategy (::std::unique_ptr< SimulationStrategy_type > x)
{
  this->SimulationStrategy_.set (std::move (x));
}

const simulation_t::Dimensions_optional& simulation_t::
Dimensions () const
{
  return this->Dimensions_;
}

simulation_t::Dimensions_optional& simulation_t::
Dimensions ()
{
  return this->Dimensions_;
}

void simulation_t::
Dimensions (const Dimensions_type& x)
{
  this->Dimensions_.set (x);
}

void simulation_t::
Dimensions (const Dimensions_optional& x)
{
  this->Dimensions_ = x;
}

void simulation_t::
Dimensions (::std::unique_ptr< Dimensions_type > x)
{
  this->Dimensions_.set (std::move (x));
}

const simulation_t::LogLevel_optional& simulation_t::
LogLevel () const
{
  return this->LogLevel_;
}

simulation_t::LogLevel_optional& simulation_t::
LogLevel ()
{
  return this->LogLevel_;
}

void simulation_t::
LogLevel (const LogLevel_type& x)
{
  this->LogLevel_.set (x);
}

void simulation_t::
LogLevel (const LogLevel_optional& x)
{
  this->LogLevel_ = x;
}

void simulation_t::
LogLevel (::std::unique_ptr< LogLevel_type > x)
{
  this->LogLevel_.set (std::move (x));
}

const simulation_t::Benchmark_optional& simulation_t::
Benchmark () const
{
  return this->Benchmark_;
}

simulation_t::Benchmark_optional& simulation_t::
Benchmark ()
{
  return this->Benchmark_;
}

void simulation_t::
Benchmark (const Benchmark_type& x)
{
  this->Benchmark_.set (x);
}

void simulation_t::
Benchmark (const Benchmark_optional& x)
{
  this->Benchmark_ = x;
}

void simulation_t::
Benchmark (::std::unique_ptr< Benchmark_type > x)
{
  this->Benchmark_.set (std::move (x));
}

const simulation_t::ShapeList_type& simulation_t::
ShapeList () const
{
  return this->ShapeList_.get ();
}

simulation_t::ShapeList_type& simulation_t::
ShapeList ()
{
  return this->ShapeList_.get ();
}

void simulation_t::
ShapeList (const ShapeList_type& x)
{
  this->ShapeList_.set (x);
}

void simulation_t::
ShapeList (::std::unique_ptr< ShapeList_type > x)
{
  this->ShapeList_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// dvector_t
//

dvector_t::
dvector_t (const X_type& X,
           const Y_type& Y,
           const Z_type& Z)
: ::xml_schema::type (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

dvector_t::
dvector_t (const dvector_t& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

dvector_t::
dvector_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void dvector_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Z",
      "");
  }
}

dvector_t* dvector_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dvector_t (*this, f, c);
}

dvector_t& dvector_t::
operator= (const dvector_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

dvector_t::
~dvector_t ()
{
}

// ivector_t
//

ivector_t::
ivector_t (const X_type& X,
           const Y_type& Y,
           const Z_type& Z)
: ::xml_schema::type (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

ivector_t::
ivector_t (const ivector_t& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

ivector_t::
ivector_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void ivector_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Z",
      "");
  }
}

ivector_t* ivector_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ivector_t (*this, f, c);
}

ivector_t& ivector_t::
operator= (const ivector_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

ivector_t::
~ivector_t ()
{
}

// nonNegativeDouble_t
//

nonNegativeDouble_t::
nonNegativeDouble_t (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

nonNegativeDouble_t::
nonNegativeDouble_t (const nonNegativeDouble_t& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

nonNegativeDouble_t::
nonNegativeDouble_t (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

nonNegativeDouble_t::
nonNegativeDouble_t (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

nonNegativeDouble_t::
nonNegativeDouble_t (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

nonNegativeDouble_t* nonNegativeDouble_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class nonNegativeDouble_t (*this, f, c);
}

nonNegativeDouble_t::
~nonNegativeDouble_t ()
{
}

// positiveDouble_t
//

positiveDouble_t::
positiveDouble_t (const ::xml_schema::double_& _xsd_double__base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (_xsd_double__base)
{
}

positiveDouble_t::
positiveDouble_t (const positiveDouble_t& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (x, f, c)
{
}

positiveDouble_t::
positiveDouble_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (e, f, c)
{
}

positiveDouble_t::
positiveDouble_t (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (a, f, c)
{
}

positiveDouble_t::
positiveDouble_t (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ > (s, e, f, c)
{
}

positiveDouble_t* positiveDouble_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positiveDouble_t (*this, f, c);
}

positiveDouble_t::
~positiveDouble_t ()
{
}

// posDVector_t
//

posDVector_t::
posDVector_t (const X_type& X,
              const Y_type& Y,
              const Z_type& Z)
: ::xml_schema::type (),
  X_ (X, this),
  Y_ (Y, this),
  Z_ (Z, this)
{
}

posDVector_t::
posDVector_t (const posDVector_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  X_ (x.X_, f, this),
  Y_ (x.Y_, f, this),
  Z_ (x.Z_, f, this)
{
}

posDVector_t::
posDVector_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  X_ (this),
  Y_ (this),
  Z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void posDVector_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "X" && n.namespace_ ().empty ())
    {
      this->X_.set (X_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Y" && n.namespace_ ().empty ())
    {
      this->Y_.set (Y_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Z" && n.namespace_ ().empty ())
    {
      this->Z_.set (Z_traits::create (i, f, this));
      continue;
    }
  }

  if (!X_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "X",
      "");
  }

  if (!Y_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Y",
      "");
  }

  if (!Z_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Z",
      "");
  }
}

posDVector_t* posDVector_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class posDVector_t (*this, f, c);
}

posDVector_t& posDVector_t::
operator= (const posDVector_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->X_ = x.X_;
    this->Y_ = x.Y_;
    this->Z_ = x.Z_;
  }

  return *this;
}

posDVector_t::
~posDVector_t ()
{
}

// output_t
//

output_t::
output_t ()
: ::xml_schema::type (),
  FolderPath_ (this),
  OutputFileName_ (this)
{
}

output_t::
output_t (const output_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  FolderPath_ (x.FolderPath_, f, this),
  OutputFileName_ (x.OutputFileName_, f, this)
{
}

output_t::
output_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  FolderPath_ (this),
  OutputFileName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void output_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "FolderPath" && n.namespace_ ().empty ())
    {
      this->FolderPath_.set (FolderPath_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "OutputFileName" && n.namespace_ ().empty ())
    {
      this->OutputFileName_.set (OutputFileName_traits::create (i, f, this));
      continue;
    }
  }
}

output_t* output_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class output_t (*this, f, c);
}

output_t& output_t::
operator= (const output_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->FolderPath_ = x.FolderPath_;
    this->OutputFileName_ = x.OutputFileName_;
  }

  return *this;
}

output_t::
~output_t ()
{
}

// outputWriter_t
//

outputWriter_t::
outputWriter_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_outputWriter_t_convert ();
}

outputWriter_t::
outputWriter_t (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_outputWriter_t_convert ();
}

outputWriter_t::
outputWriter_t (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_outputWriter_t_convert ();
}

outputWriter_t* outputWriter_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class outputWriter_t (*this, f, c);
}

outputWriter_t::value outputWriter_t::
_xsd_outputWriter_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_outputWriter_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_outputWriter_t_indexes_,
                    _xsd_outputWriter_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_outputWriter_t_indexes_ + 2 || _xsd_outputWriter_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const outputWriter_t::
_xsd_outputWriter_t_literals_[2] =
{
  "Vtk",
  "Xyz"
};

const outputWriter_t::value outputWriter_t::
_xsd_outputWriter_t_indexes_[2] =
{
  ::outputWriter_t::Vtk,
  ::outputWriter_t::Xyz
};

// gravity_t
//

gravity_t::
gravity_t ()
: ::xml_schema::type ()
{
}

gravity_t::
gravity_t (const gravity_t& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

gravity_t::
gravity_t (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

gravity_t::
gravity_t (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

gravity_t::
gravity_t (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

gravity_t* gravity_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class gravity_t (*this, f, c);
}

gravity_t::
~gravity_t ()
{
}

// lennardJones_t
//

lennardJones_t::
lennardJones_t ()
: ::xml_schema::type (),
  Epsilon_ (this),
  Sigma_ (this)
{
}

lennardJones_t::
lennardJones_t (const lennardJones_t& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Epsilon_ (x.Epsilon_, f, this),
  Sigma_ (x.Sigma_, f, this)
{
}

lennardJones_t::
lennardJones_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Epsilon_ (this),
  Sigma_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void lennardJones_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Epsilon" && n.namespace_ ().empty ())
    {
      this->Epsilon_.set (Epsilon_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Sigma" && n.namespace_ ().empty ())
    {
      this->Sigma_.set (Sigma_traits::create (i, f, this));
      continue;
    }
  }
}

lennardJones_t* lennardJones_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class lennardJones_t (*this, f, c);
}

lennardJones_t& lennardJones_t::
operator= (const lennardJones_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Epsilon_ = x.Epsilon_;
    this->Sigma_ = x.Sigma_;
  }

  return *this;
}

lennardJones_t::
~lennardJones_t ()
{
}

// forceCalculation_t
//

forceCalculation_t::
forceCalculation_t ()
: ::xml_schema::type (),
  Gravity_ (this),
  LennardJones_ (this)
{
}

forceCalculation_t::
forceCalculation_t (const forceCalculation_t& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Gravity_ (x.Gravity_, f, this),
  LennardJones_ (x.LennardJones_, f, this)
{
}

forceCalculation_t::
forceCalculation_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Gravity_ (this),
  LennardJones_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void forceCalculation_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Gravity
    //
    if (n.name () == "Gravity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Gravity_type > r (
        Gravity_traits::create (i, f, this));

      if (!this->Gravity_)
      {
        this->Gravity_.set (::std::move (r));
        continue;
      }
    }

    // LennardJones
    //
    if (n.name () == "LennardJones" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< LennardJones_type > r (
        LennardJones_traits::create (i, f, this));

      if (!this->LennardJones_)
      {
        this->LennardJones_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

forceCalculation_t* forceCalculation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class forceCalculation_t (*this, f, c);
}

forceCalculation_t& forceCalculation_t::
operator= (const forceCalculation_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Gravity_ = x.Gravity_;
    this->LennardJones_ = x.LennardJones_;
  }

  return *this;
}

forceCalculation_t::
~forceCalculation_t ()
{
}

// positionCalculation_t
//

positionCalculation_t::
positionCalculation_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_positionCalculation_t_convert ();
}

positionCalculation_t::
positionCalculation_t (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_positionCalculation_t_convert ();
}

positionCalculation_t::
positionCalculation_t (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_positionCalculation_t_convert ();
}

positionCalculation_t* positionCalculation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class positionCalculation_t (*this, f, c);
}

positionCalculation_t::value positionCalculation_t::
_xsd_positionCalculation_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_positionCalculation_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_positionCalculation_t_indexes_,
                    _xsd_positionCalculation_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_positionCalculation_t_indexes_ + 2 || _xsd_positionCalculation_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const positionCalculation_t::
_xsd_positionCalculation_t_literals_[2] =
{
  "StoermerVelvet",
  "StoermerVelvetOMP"
};

const positionCalculation_t::value positionCalculation_t::
_xsd_positionCalculation_t_indexes_[2] =
{
  ::positionCalculation_t::StoermerVelvet,
  ::positionCalculation_t::StoermerVelvetOMP
};

// velocityCalculation_t
//

velocityCalculation_t::
velocityCalculation_t (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_velocityCalculation_t_convert ();
}

velocityCalculation_t::
velocityCalculation_t (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_velocityCalculation_t_convert ();
}

velocityCalculation_t::
velocityCalculation_t (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_velocityCalculation_t_convert ();
}

velocityCalculation_t* velocityCalculation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class velocityCalculation_t (*this, f, c);
}

velocityCalculation_t::value velocityCalculation_t::
_xsd_velocityCalculation_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_velocityCalculation_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_velocityCalculation_t_indexes_,
                    _xsd_velocityCalculation_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_velocityCalculation_t_indexes_ + 2 || _xsd_velocityCalculation_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const velocityCalculation_t::
_xsd_velocityCalculation_t_literals_[2] =
{
  "StoermerVelvet",
  "StoermerVelvetOMP"
};

const velocityCalculation_t::value velocityCalculation_t::
_xsd_velocityCalculation_t_indexes_[2] =
{
  ::velocityCalculation_t::StoermerVelvet,
  ::velocityCalculation_t::StoermerVelvetOMP
};

// boundaryBehavior_t
//

boundaryBehavior_t::
boundaryBehavior_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_boundaryBehavior_t_convert ();
}

boundaryBehavior_t::
boundaryBehavior_t (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_boundaryBehavior_t_convert ();
}

boundaryBehavior_t::
boundaryBehavior_t (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_boundaryBehavior_t_convert ();
}

boundaryBehavior_t* boundaryBehavior_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaryBehavior_t (*this, f, c);
}

boundaryBehavior_t::value boundaryBehavior_t::
_xsd_boundaryBehavior_t_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_boundaryBehavior_t_literals_);
  const value* i (::std::lower_bound (
                    _xsd_boundaryBehavior_t_indexes_,
                    _xsd_boundaryBehavior_t_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_boundaryBehavior_t_indexes_ + 2 || _xsd_boundaryBehavior_t_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const boundaryBehavior_t::
_xsd_boundaryBehavior_t_literals_[2] =
{
  "Outflow",
  "Reflection"
};

const boundaryBehavior_t::value boundaryBehavior_t::
_xsd_boundaryBehavior_t_indexes_[2] =
{
  ::boundaryBehavior_t::Outflow,
  ::boundaryBehavior_t::Reflection
};

// boundaries_t
//

boundaries_t::
boundaries_t (const BoxSize_type& BoxSize,
              const Front_type& Front,
              const Rear_type& Rear,
              const Left_type& Left,
              const Right_type& Right,
              const Top_type& Top,
              const Bottom_type& Bottom)
: ::xml_schema::type (),
  BoxSize_ (BoxSize, this),
  Front_ (Front, this),
  Rear_ (Rear, this),
  Left_ (Left, this),
  Right_ (Right, this),
  Top_ (Top, this),
  Bottom_ (Bottom, this)
{
}

boundaries_t::
boundaries_t (::std::unique_ptr< BoxSize_type > BoxSize,
              const Front_type& Front,
              const Rear_type& Rear,
              const Left_type& Left,
              const Right_type& Right,
              const Top_type& Top,
              const Bottom_type& Bottom)
: ::xml_schema::type (),
  BoxSize_ (std::move (BoxSize), this),
  Front_ (Front, this),
  Rear_ (Rear, this),
  Left_ (Left, this),
  Right_ (Right, this),
  Top_ (Top, this),
  Bottom_ (Bottom, this)
{
}

boundaries_t::
boundaries_t (const boundaries_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  BoxSize_ (x.BoxSize_, f, this),
  Front_ (x.Front_, f, this),
  Rear_ (x.Rear_, f, this),
  Left_ (x.Left_, f, this),
  Right_ (x.Right_, f, this),
  Top_ (x.Top_, f, this),
  Bottom_ (x.Bottom_, f, this)
{
}

boundaries_t::
boundaries_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  BoxSize_ (this),
  Front_ (this),
  Rear_ (this),
  Left_ (this),
  Right_ (this),
  Top_ (this),
  Bottom_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundaries_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // BoxSize
    //
    if (n.name () == "BoxSize" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< BoxSize_type > r (
        BoxSize_traits::create (i, f, this));

      if (!BoxSize_.present ())
      {
        this->BoxSize_.set (::std::move (r));
        continue;
      }
    }

    // Front
    //
    if (n.name () == "Front" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Front_type > r (
        Front_traits::create (i, f, this));

      if (!Front_.present ())
      {
        this->Front_.set (::std::move (r));
        continue;
      }
    }

    // Rear
    //
    if (n.name () == "Rear" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Rear_type > r (
        Rear_traits::create (i, f, this));

      if (!Rear_.present ())
      {
        this->Rear_.set (::std::move (r));
        continue;
      }
    }

    // Left
    //
    if (n.name () == "Left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Left_type > r (
        Left_traits::create (i, f, this));

      if (!Left_.present ())
      {
        this->Left_.set (::std::move (r));
        continue;
      }
    }

    // Right
    //
    if (n.name () == "Right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Right_type > r (
        Right_traits::create (i, f, this));

      if (!Right_.present ())
      {
        this->Right_.set (::std::move (r));
        continue;
      }
    }

    // Top
    //
    if (n.name () == "Top" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Top_type > r (
        Top_traits::create (i, f, this));

      if (!Top_.present ())
      {
        this->Top_.set (::std::move (r));
        continue;
      }
    }

    // Bottom
    //
    if (n.name () == "Bottom" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Bottom_type > r (
        Bottom_traits::create (i, f, this));

      if (!Bottom_.present ())
      {
        this->Bottom_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!BoxSize_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BoxSize",
      "");
  }

  if (!Front_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Front",
      "");
  }

  if (!Rear_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Rear",
      "");
  }

  if (!Left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Left",
      "");
  }

  if (!Right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Right",
      "");
  }

  if (!Top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Top",
      "");
  }

  if (!Bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Bottom",
      "");
  }
}

boundaries_t* boundaries_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaries_t (*this, f, c);
}

boundaries_t& boundaries_t::
operator= (const boundaries_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->BoxSize_ = x.BoxSize_;
    this->Front_ = x.Front_;
    this->Rear_ = x.Rear_;
    this->Left_ = x.Left_;
    this->Right_ = x.Right_;
    this->Top_ = x.Top_;
    this->Bottom_ = x.Bottom_;
  }

  return *this;
}

boundaries_t::
~boundaries_t ()
{
}

// linkedCell_t
//

linkedCell_t::
linkedCell_t (const BoundaryBox_type& BoundaryBox,
              const CutoffRadius_type& CutoffRadius)
: ::xml_schema::type (),
  BoundaryBox_ (BoundaryBox, this),
  CutoffRadius_ (CutoffRadius, this)
{
}

linkedCell_t::
linkedCell_t (::std::unique_ptr< BoundaryBox_type > BoundaryBox,
              const CutoffRadius_type& CutoffRadius)
: ::xml_schema::type (),
  BoundaryBox_ (std::move (BoundaryBox), this),
  CutoffRadius_ (CutoffRadius, this)
{
}

linkedCell_t::
linkedCell_t (const linkedCell_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  BoundaryBox_ (x.BoundaryBox_, f, this),
  CutoffRadius_ (x.CutoffRadius_, f, this)
{
}

linkedCell_t::
linkedCell_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  BoundaryBox_ (this),
  CutoffRadius_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void linkedCell_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // BoundaryBox
    //
    if (n.name () == "BoundaryBox" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< BoundaryBox_type > r (
        BoundaryBox_traits::create (i, f, this));

      if (!BoundaryBox_.present ())
      {
        this->BoundaryBox_.set (::std::move (r));
        continue;
      }
    }

    // CutoffRadius
    //
    if (n.name () == "CutoffRadius" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< CutoffRadius_type > r (
        CutoffRadius_traits::create (i, f, this));

      if (!CutoffRadius_.present ())
      {
        this->CutoffRadius_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!BoundaryBox_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BoundaryBox",
      "");
  }

  if (!CutoffRadius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "CutoffRadius",
      "");
  }
}

linkedCell_t* linkedCell_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class linkedCell_t (*this, f, c);
}

linkedCell_t& linkedCell_t::
operator= (const linkedCell_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->BoundaryBox_ = x.BoundaryBox_;
    this->CutoffRadius_ = x.CutoffRadius_;
  }

  return *this;
}

linkedCell_t::
~linkedCell_t ()
{
}

// naive_t
//

naive_t::
naive_t ()
: ::xml_schema::type ()
{
}

naive_t::
naive_t (const naive_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

naive_t::
naive_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

naive_t::
naive_t (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

naive_t::
naive_t (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

naive_t* naive_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class naive_t (*this, f, c);
}

naive_t::
~naive_t ()
{
}

// simulationStrategy_t
//

simulationStrategy_t::
simulationStrategy_t ()
: ::xml_schema::type (),
  LinkedCell_ (this),
  Naive_ (this)
{
}

simulationStrategy_t::
simulationStrategy_t (const simulationStrategy_t& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  LinkedCell_ (x.LinkedCell_, f, this),
  Naive_ (x.Naive_, f, this)
{
}

simulationStrategy_t::
simulationStrategy_t (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  LinkedCell_ (this),
  Naive_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulationStrategy_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // LinkedCell
    //
    if (n.name () == "LinkedCell" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< LinkedCell_type > r (
        LinkedCell_traits::create (i, f, this));

      if (!this->LinkedCell_)
      {
        this->LinkedCell_.set (::std::move (r));
        continue;
      }
    }

    // Naive
    //
    if (n.name () == "Naive" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Naive_type > r (
        Naive_traits::create (i, f, this));

      if (!this->Naive_)
      {
        this->Naive_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

simulationStrategy_t* simulationStrategy_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulationStrategy_t (*this, f, c);
}

simulationStrategy_t& simulationStrategy_t::
operator= (const simulationStrategy_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->LinkedCell_ = x.LinkedCell_;
    this->Naive_ = x.Naive_;
  }

  return *this;
}

simulationStrategy_t::
~simulationStrategy_t ()
{
}

// logLevel_t
//

logLevel_t::
logLevel_t (const ::xml_schema::non_negative_integer& _xsd_non_negative_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (_xsd_non_negative_integer_base)
{
}

logLevel_t::
logLevel_t (const logLevel_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

logLevel_t::
logLevel_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

logLevel_t::
logLevel_t (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

logLevel_t::
logLevel_t (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

logLevel_t* logLevel_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class logLevel_t (*this, f, c);
}

logLevel_t::
~logLevel_t ()
{
}

// fileBenchmark_t
//

fileBenchmark_t::
fileBenchmark_t ()
: ::xml_schema::type ()
{
}

fileBenchmark_t::
fileBenchmark_t (const fileBenchmark_t& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

fileBenchmark_t::
fileBenchmark_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

fileBenchmark_t::
fileBenchmark_t (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

fileBenchmark_t::
fileBenchmark_t (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

fileBenchmark_t* fileBenchmark_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class fileBenchmark_t (*this, f, c);
}

fileBenchmark_t::
~fileBenchmark_t ()
{
}

// defaultBenchmark_t
//

defaultBenchmark_t::
defaultBenchmark_t ()
: ::xml_schema::type (),
  MaximumBodySize_ (this)
{
}

defaultBenchmark_t::
defaultBenchmark_t (const defaultBenchmark_t& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MaximumBodySize_ (x.MaximumBodySize_, f, this)
{
}

defaultBenchmark_t::
defaultBenchmark_t (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MaximumBodySize_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void defaultBenchmark_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "MaximumBodySize" && n.namespace_ ().empty ())
    {
      this->MaximumBodySize_.set (MaximumBodySize_traits::create (i, f, this));
      continue;
    }
  }
}

defaultBenchmark_t* defaultBenchmark_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class defaultBenchmark_t (*this, f, c);
}

defaultBenchmark_t& defaultBenchmark_t::
operator= (const defaultBenchmark_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->MaximumBodySize_ = x.MaximumBodySize_;
  }

  return *this;
}

defaultBenchmark_t::
~defaultBenchmark_t ()
{
}

// benchmarkType_t
//

benchmarkType_t::
benchmarkType_t ()
: ::xml_schema::type (),
  FileBenchmark_ (this),
  DefaultBenchmark_ (this)
{
}

benchmarkType_t::
benchmarkType_t (const benchmarkType_t& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  FileBenchmark_ (x.FileBenchmark_, f, this),
  DefaultBenchmark_ (x.DefaultBenchmark_, f, this)
{
}

benchmarkType_t::
benchmarkType_t (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  FileBenchmark_ (this),
  DefaultBenchmark_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void benchmarkType_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FileBenchmark
    //
    if (n.name () == "FileBenchmark" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< FileBenchmark_type > r (
        FileBenchmark_traits::create (i, f, this));

      if (!this->FileBenchmark_)
      {
        this->FileBenchmark_.set (::std::move (r));
        continue;
      }
    }

    // DefaultBenchmark
    //
    if (n.name () == "DefaultBenchmark" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< DefaultBenchmark_type > r (
        DefaultBenchmark_traits::create (i, f, this));

      if (!this->DefaultBenchmark_)
      {
        this->DefaultBenchmark_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

benchmarkType_t* benchmarkType_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class benchmarkType_t (*this, f, c);
}

benchmarkType_t& benchmarkType_t::
operator= (const benchmarkType_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->FileBenchmark_ = x.FileBenchmark_;
    this->DefaultBenchmark_ = x.DefaultBenchmark_;
  }

  return *this;
}

benchmarkType_t::
~benchmarkType_t ()
{
}

// benchmark_t
//

benchmark_t::
benchmark_t (const BenchmarkType_type& BenchmarkType)
: ::xml_schema::type (),
  BenchmarkType_ (BenchmarkType, this),
  IterationCount_ (this)
{
}

benchmark_t::
benchmark_t (::std::unique_ptr< BenchmarkType_type > BenchmarkType)
: ::xml_schema::type (),
  BenchmarkType_ (std::move (BenchmarkType), this),
  IterationCount_ (this)
{
}

benchmark_t::
benchmark_t (const benchmark_t& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  BenchmarkType_ (x.BenchmarkType_, f, this),
  IterationCount_ (x.IterationCount_, f, this)
{
}

benchmark_t::
benchmark_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  BenchmarkType_ (this),
  IterationCount_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void benchmark_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // BenchmarkType
    //
    if (n.name () == "BenchmarkType" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< BenchmarkType_type > r (
        BenchmarkType_traits::create (i, f, this));

      if (!BenchmarkType_.present ())
      {
        this->BenchmarkType_.set (::std::move (r));
        continue;
      }
    }

    // IterationCount
    //
    if (n.name () == "IterationCount" && n.namespace_ ().empty ())
    {
      if (!this->IterationCount_)
      {
        this->IterationCount_.set (IterationCount_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!BenchmarkType_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "BenchmarkType",
      "");
  }
}

benchmark_t* benchmark_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class benchmark_t (*this, f, c);
}

benchmark_t& benchmark_t::
operator= (const benchmark_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->BenchmarkType_ = x.BenchmarkType_;
    this->IterationCount_ = x.IterationCount_;
  }

  return *this;
}

benchmark_t::
~benchmark_t ()
{
}

// dimension_t
//

dimension_t::
dimension_t (const ::xml_schema::positive_integer& _xsd_positive_integer_base)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (_xsd_positive_integer_base)
{
}

dimension_t::
dimension_t (const dimension_t& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

dimension_t::
dimension_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

dimension_t::
dimension_t (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

dimension_t::
dimension_t (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

dimension_t* dimension_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class dimension_t (*this, f, c);
}

dimension_t::
~dimension_t ()
{
}

// particle_t
//

particle_t::
particle_t (const Position_type& Position,
            const Velocity_type& Velocity,
            const Mass_type& Mass)
: ::xml_schema::type (),
  Position_ (Position, this),
  Velocity_ (Velocity, this),
  Mass_ (Mass, this)
{
}

particle_t::
particle_t (::std::unique_ptr< Position_type > Position,
            ::std::unique_ptr< Velocity_type > Velocity,
            const Mass_type& Mass)
: ::xml_schema::type (),
  Position_ (std::move (Position), this),
  Velocity_ (std::move (Velocity), this),
  Mass_ (Mass, this)
{
}

particle_t::
particle_t (const particle_t& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Position_ (x.Position_, f, this),
  Velocity_ (x.Velocity_, f, this),
  Mass_ (x.Mass_, f, this)
{
}

particle_t::
particle_t (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Position_ (this),
  Velocity_ (this),
  Mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void particle_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (::std::move (r));
        continue;
      }
    }

    // Velocity
    //
    if (n.name () == "Velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Velocity_type > r (
        Velocity_traits::create (i, f, this));

      if (!Velocity_.present ())
      {
        this->Velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }

  if (!Velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Mass" && n.namespace_ ().empty ())
    {
      this->Mass_.set (Mass_traits::create (i, f, this));
      continue;
    }
  }

  if (!Mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Mass",
      "");
  }
}

particle_t* particle_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particle_t (*this, f, c);
}

particle_t& particle_t::
operator= (const particle_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Position_ = x.Position_;
    this->Velocity_ = x.Velocity_;
    this->Mass_ = x.Mass_;
  }

  return *this;
}

particle_t::
~particle_t ()
{
}

// cuboid_t
//

cuboid_t::
cuboid_t (const Position_type& Position,
          const Velocity_type& Velocity,
          const Dimensions_type& Dimensions,
          const Spacing_type& Spacing,
          const Mass_type& Mass)
: ::xml_schema::type (),
  Position_ (Position, this),
  Velocity_ (Velocity, this),
  Dimensions_ (Dimensions, this),
  Spacing_ (Spacing, this),
  Mass_ (Mass, this)
{
}

cuboid_t::
cuboid_t (::std::unique_ptr< Position_type > Position,
          ::std::unique_ptr< Velocity_type > Velocity,
          ::std::unique_ptr< Dimensions_type > Dimensions,
          const Spacing_type& Spacing,
          const Mass_type& Mass)
: ::xml_schema::type (),
  Position_ (std::move (Position), this),
  Velocity_ (std::move (Velocity), this),
  Dimensions_ (std::move (Dimensions), this),
  Spacing_ (Spacing, this),
  Mass_ (Mass, this)
{
}

cuboid_t::
cuboid_t (const cuboid_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Position_ (x.Position_, f, this),
  Velocity_ (x.Velocity_, f, this),
  Dimensions_ (x.Dimensions_, f, this),
  Spacing_ (x.Spacing_, f, this),
  Mass_ (x.Mass_, f, this)
{
}

cuboid_t::
cuboid_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Position_ (this),
  Velocity_ (this),
  Dimensions_ (this),
  Spacing_ (this),
  Mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void cuboid_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (::std::move (r));
        continue;
      }
    }

    // Velocity
    //
    if (n.name () == "Velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Velocity_type > r (
        Velocity_traits::create (i, f, this));

      if (!Velocity_.present ())
      {
        this->Velocity_.set (::std::move (r));
        continue;
      }
    }

    // Dimensions
    //
    if (n.name () == "Dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Dimensions_type > r (
        Dimensions_traits::create (i, f, this));

      if (!Dimensions_.present ())
      {
        this->Dimensions_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }

  if (!Velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity",
      "");
  }

  if (!Dimensions_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Dimensions",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Spacing" && n.namespace_ ().empty ())
    {
      this->Spacing_.set (Spacing_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Mass" && n.namespace_ ().empty ())
    {
      this->Mass_.set (Mass_traits::create (i, f, this));
      continue;
    }
  }

  if (!Spacing_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Spacing",
      "");
  }

  if (!Mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Mass",
      "");
  }
}

cuboid_t* cuboid_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid_t (*this, f, c);
}

cuboid_t& cuboid_t::
operator= (const cuboid_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Position_ = x.Position_;
    this->Velocity_ = x.Velocity_;
    this->Dimensions_ = x.Dimensions_;
    this->Spacing_ = x.Spacing_;
    this->Mass_ = x.Mass_;
  }

  return *this;
}

cuboid_t::
~cuboid_t ()
{
}

// sphere_t
//

sphere_t::
sphere_t (const Position_type& Position,
          const Velocity_type& Velocity,
          const Radius_type& Radius,
          const Spacing_type& Spacing,
          const Mass_type& Mass)
: ::xml_schema::type (),
  Position_ (Position, this),
  Velocity_ (Velocity, this),
  Radius_ (Radius, this),
  Spacing_ (Spacing, this),
  Mass_ (Mass, this)
{
}

sphere_t::
sphere_t (::std::unique_ptr< Position_type > Position,
          ::std::unique_ptr< Velocity_type > Velocity,
          const Radius_type& Radius,
          const Spacing_type& Spacing,
          const Mass_type& Mass)
: ::xml_schema::type (),
  Position_ (std::move (Position), this),
  Velocity_ (std::move (Velocity), this),
  Radius_ (Radius, this),
  Spacing_ (Spacing, this),
  Mass_ (Mass, this)
{
}

sphere_t::
sphere_t (const sphere_t& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Position_ (x.Position_, f, this),
  Velocity_ (x.Velocity_, f, this),
  Radius_ (x.Radius_, f, this),
  Spacing_ (x.Spacing_, f, this),
  Mass_ (x.Mass_, f, this)
{
}

sphere_t::
sphere_t (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Position_ (this),
  Velocity_ (this),
  Radius_ (this),
  Spacing_ (this),
  Mass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void sphere_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Position
    //
    if (n.name () == "Position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Position_type > r (
        Position_traits::create (i, f, this));

      if (!Position_.present ())
      {
        this->Position_.set (::std::move (r));
        continue;
      }
    }

    // Velocity
    //
    if (n.name () == "Velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Velocity_type > r (
        Velocity_traits::create (i, f, this));

      if (!Velocity_.present ())
      {
        this->Velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!Position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Position",
      "");
  }

  if (!Velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Velocity",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Radius" && n.namespace_ ().empty ())
    {
      this->Radius_.set (Radius_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Spacing" && n.namespace_ ().empty ())
    {
      this->Spacing_.set (Spacing_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Mass" && n.namespace_ ().empty ())
    {
      this->Mass_.set (Mass_traits::create (i, f, this));
      continue;
    }
  }

  if (!Radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Radius",
      "");
  }

  if (!Spacing_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Spacing",
      "");
  }

  if (!Mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Mass",
      "");
  }
}

sphere_t* sphere_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere_t (*this, f, c);
}

sphere_t& sphere_t::
operator= (const sphere_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Position_ = x.Position_;
    this->Velocity_ = x.Velocity_;
    this->Radius_ = x.Radius_;
    this->Spacing_ = x.Spacing_;
    this->Mass_ = x.Mass_;
  }

  return *this;
}

sphere_t::
~sphere_t ()
{
}

// shape_t
//

shape_t::
shape_t ()
: ::xml_schema::type (),
  Particle_ (this),
  Cuboid_ (this),
  Sphere_ (this)
{
}

shape_t::
shape_t (const shape_t& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Particle_ (x.Particle_, f, this),
  Cuboid_ (x.Cuboid_, f, this),
  Sphere_ (x.Sphere_, f, this)
{
}

shape_t::
shape_t (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Particle_ (this),
  Cuboid_ (this),
  Sphere_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void shape_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Particle
    //
    if (n.name () == "Particle" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Particle_type > r (
        Particle_traits::create (i, f, this));

      if (!this->Particle_)
      {
        this->Particle_.set (::std::move (r));
        continue;
      }
    }

    // Cuboid
    //
    if (n.name () == "Cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Cuboid_type > r (
        Cuboid_traits::create (i, f, this));

      if (!this->Cuboid_)
      {
        this->Cuboid_.set (::std::move (r));
        continue;
      }
    }

    // Sphere
    //
    if (n.name () == "Sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Sphere_type > r (
        Sphere_traits::create (i, f, this));

      if (!this->Sphere_)
      {
        this->Sphere_.set (::std::move (r));
        continue;
      }
    }

    break;
  }
}

shape_t* shape_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class shape_t (*this, f, c);
}

shape_t& shape_t::
operator= (const shape_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Particle_ = x.Particle_;
    this->Cuboid_ = x.Cuboid_;
    this->Sphere_ = x.Sphere_;
  }

  return *this;
}

shape_t::
~shape_t ()
{
}

// shapeList_t
//

shapeList_t::
shapeList_t ()
: ::xml_schema::type (),
  Shape_ (this)
{
}

shapeList_t::
shapeList_t (const shapeList_t& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Shape_ (x.Shape_, f, this)
{
}

shapeList_t::
shapeList_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Shape_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void shapeList_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      this->Shape_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

shapeList_t* shapeList_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class shapeList_t (*this, f, c);
}

shapeList_t& shapeList_t::
operator= (const shapeList_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Shape_ = x.Shape_;
  }

  return *this;
}

shapeList_t::
~shapeList_t ()
{
}

// simulation_t
//

simulation_t::
simulation_t (const ForceCalculation_type& ForceCalculation,
              const SimulationStrategy_type& SimulationStrategy,
              const ShapeList_type& ShapeList)
: ::xml_schema::type (),
  OutputFile_ (this),
  StartTime_ (this),
  EndTime_ (this),
  TimeStepSize_ (this),
  ForceCalculation_ (ForceCalculation, this),
  PositionCalculation_ (this),
  VelocityCalculation_ (this),
  AverageBrownianMotion_ (this),
  SimulationStrategy_ (SimulationStrategy, this),
  Dimensions_ (this),
  LogLevel_ (this),
  Benchmark_ (this),
  ShapeList_ (ShapeList, this)
{
}

simulation_t::
simulation_t (::std::unique_ptr< ForceCalculation_type > ForceCalculation,
              ::std::unique_ptr< SimulationStrategy_type > SimulationStrategy,
              ::std::unique_ptr< ShapeList_type > ShapeList)
: ::xml_schema::type (),
  OutputFile_ (this),
  StartTime_ (this),
  EndTime_ (this),
  TimeStepSize_ (this),
  ForceCalculation_ (std::move (ForceCalculation), this),
  PositionCalculation_ (this),
  VelocityCalculation_ (this),
  AverageBrownianMotion_ (this),
  SimulationStrategy_ (std::move (SimulationStrategy), this),
  Dimensions_ (this),
  LogLevel_ (this),
  Benchmark_ (this),
  ShapeList_ (std::move (ShapeList), this)
{
}

simulation_t::
simulation_t (const simulation_t& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  OutputFile_ (x.OutputFile_, f, this),
  StartTime_ (x.StartTime_, f, this),
  EndTime_ (x.EndTime_, f, this),
  TimeStepSize_ (x.TimeStepSize_, f, this),
  ForceCalculation_ (x.ForceCalculation_, f, this),
  PositionCalculation_ (x.PositionCalculation_, f, this),
  VelocityCalculation_ (x.VelocityCalculation_, f, this),
  AverageBrownianMotion_ (x.AverageBrownianMotion_, f, this),
  SimulationStrategy_ (x.SimulationStrategy_, f, this),
  Dimensions_ (x.Dimensions_, f, this),
  LogLevel_ (x.LogLevel_, f, this),
  Benchmark_ (x.Benchmark_, f, this),
  ShapeList_ (x.ShapeList_, f, this)
{
}

simulation_t::
simulation_t (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  OutputFile_ (this),
  StartTime_ (this),
  EndTime_ (this),
  TimeStepSize_ (this),
  ForceCalculation_ (this),
  PositionCalculation_ (this),
  VelocityCalculation_ (this),
  AverageBrownianMotion_ (this),
  SimulationStrategy_ (this),
  Dimensions_ (this),
  LogLevel_ (this),
  Benchmark_ (this),
  ShapeList_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void simulation_t::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // OutputFile
    //
    if (n.name () == "OutputFile" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< OutputFile_type > r (
        OutputFile_traits::create (i, f, this));

      if (!this->OutputFile_)
      {
        this->OutputFile_.set (::std::move (r));
        continue;
      }
    }

    // StartTime
    //
    if (n.name () == "StartTime" && n.namespace_ ().empty ())
    {
      if (!this->StartTime_)
      {
        this->StartTime_.set (StartTime_traits::create (i, f, this));
        continue;
      }
    }

    // EndTime
    //
    if (n.name () == "EndTime" && n.namespace_ ().empty ())
    {
      if (!this->EndTime_)
      {
        this->EndTime_.set (EndTime_traits::create (i, f, this));
        continue;
      }
    }

    // TimeStepSize
    //
    if (n.name () == "TimeStepSize" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< TimeStepSize_type > r (
        TimeStepSize_traits::create (i, f, this));

      if (!this->TimeStepSize_)
      {
        this->TimeStepSize_.set (::std::move (r));
        continue;
      }
    }

    // ForceCalculation
    //
    if (n.name () == "ForceCalculation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ForceCalculation_type > r (
        ForceCalculation_traits::create (i, f, this));

      if (!ForceCalculation_.present ())
      {
        this->ForceCalculation_.set (::std::move (r));
        continue;
      }
    }

    // PositionCalculation
    //
    if (n.name () == "PositionCalculation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< PositionCalculation_type > r (
        PositionCalculation_traits::create (i, f, this));

      if (!this->PositionCalculation_)
      {
        this->PositionCalculation_.set (::std::move (r));
        continue;
      }
    }

    // VelocityCalculation
    //
    if (n.name () == "VelocityCalculation" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< VelocityCalculation_type > r (
        VelocityCalculation_traits::create (i, f, this));

      if (!this->VelocityCalculation_)
      {
        this->VelocityCalculation_.set (::std::move (r));
        continue;
      }
    }

    // AverageBrownianMotion
    //
    if (n.name () == "AverageBrownianMotion" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< AverageBrownianMotion_type > r (
        AverageBrownianMotion_traits::create (i, f, this));

      if (!this->AverageBrownianMotion_)
      {
        this->AverageBrownianMotion_.set (::std::move (r));
        continue;
      }
    }

    // SimulationStrategy
    //
    if (n.name () == "SimulationStrategy" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< SimulationStrategy_type > r (
        SimulationStrategy_traits::create (i, f, this));

      if (!SimulationStrategy_.present ())
      {
        this->SimulationStrategy_.set (::std::move (r));
        continue;
      }
    }

    // Dimensions
    //
    if (n.name () == "Dimensions" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Dimensions_type > r (
        Dimensions_traits::create (i, f, this));

      if (!this->Dimensions_)
      {
        this->Dimensions_.set (::std::move (r));
        continue;
      }
    }

    // LogLevel
    //
    if (n.name () == "LogLevel" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< LogLevel_type > r (
        LogLevel_traits::create (i, f, this));

      if (!this->LogLevel_)
      {
        this->LogLevel_.set (::std::move (r));
        continue;
      }
    }

    // Benchmark
    //
    if (n.name () == "Benchmark" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< Benchmark_type > r (
        Benchmark_traits::create (i, f, this));

      if (!this->Benchmark_)
      {
        this->Benchmark_.set (::std::move (r));
        continue;
      }
    }

    // ShapeList
    //
    if (n.name () == "ShapeList" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< ShapeList_type > r (
        ShapeList_traits::create (i, f, this));

      if (!ShapeList_.present ())
      {
        this->ShapeList_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!ForceCalculation_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ForceCalculation",
      "");
  }

  if (!SimulationStrategy_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "SimulationStrategy",
      "");
  }

  if (!ShapeList_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ShapeList",
      "");
  }
}

simulation_t* simulation_t::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class simulation_t (*this, f, c);
}

simulation_t& simulation_t::
operator= (const simulation_t& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->OutputFile_ = x.OutputFile_;
    this->StartTime_ = x.StartTime_;
    this->EndTime_ = x.EndTime_;
    this->TimeStepSize_ = x.TimeStepSize_;
    this->ForceCalculation_ = x.ForceCalculation_;
    this->PositionCalculation_ = x.PositionCalculation_;
    this->VelocityCalculation_ = x.VelocityCalculation_;
    this->AverageBrownianMotion_ = x.AverageBrownianMotion_;
    this->SimulationStrategy_ = x.SimulationStrategy_;
    this->Dimensions_ = x.Dimensions_;
    this->LogLevel_ = x.LogLevel_;
    this->Benchmark_ = x.Benchmark_;
    this->ShapeList_ = x.ShapeList_;
  }

  return *this;
}

simulation_t::
~simulation_t ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::simulation_t >
Simulation (const ::std::string& u,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (const ::std::string& u,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (const ::std::string& u,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Simulation (isrc, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Simulation (isrc, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            const ::std::string& sid,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::std::istream& is,
            const ::std::string& sid,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::Simulation (isrc, h, f, p);
}

::std::unique_ptr< ::simulation_t >
Simulation (::xercesc::InputSource& i,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (::xercesc::InputSource& i,
            ::xml_schema::error_handler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (::xercesc::InputSource& i,
            ::xercesc::DOMErrorHandler& h,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::simulation_t > (
    ::Simulation (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::simulation_t >
Simulation (const ::xercesc::DOMDocument& doc,
            ::xml_schema::flags f,
            const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::simulation_t > (
      ::Simulation (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation_t > r (
      ::xsd::cxx::tree::traits< ::simulation_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Simulation",
    "");
}

::std::unique_ptr< ::simulation_t >
Simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f,
            const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "Simulation" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::simulation_t > r (
      ::xsd::cxx::tree::traits< ::simulation_t, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "Simulation",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const dvector_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // X
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "X",
        e));

    a << ::xml_schema::as_double(i.X ());
  }

  // Y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Y",
        e));

    a << ::xml_schema::as_double(i.Y ());
  }

  // Z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Z",
        e));

    a << ::xml_schema::as_double(i.Z ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const ivector_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // X
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "X",
        e));

    a << i.X ();
  }

  // Y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Y",
        e));

    a << i.Y ();
  }

  // Z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Z",
        e));

    a << i.Z ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const nonNegativeDouble_t& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const nonNegativeDouble_t& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const nonNegativeDouble_t& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const positiveDouble_t& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const positiveDouble_t& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const positiveDouble_t& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const posDVector_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // X
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "X",
        e));

    a << i.X ();
  }

  // Y
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Y",
        e));

    a << i.Y ();
  }

  // Z
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Z",
        e));

    a << i.Z ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const output_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // FolderPath
  //
  if (i.FolderPath ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "FolderPath",
        e));

    a << *i.FolderPath ();
  }

  // OutputFileName
  //
  if (i.OutputFileName ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "OutputFileName",
        e));

    a << *i.OutputFileName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const outputWriter_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const outputWriter_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const outputWriter_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const gravity_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMAttr&, const gravity_t&)
{
}

void
operator<< (::xml_schema::list_stream&,
            const gravity_t&)
{
}

void
operator<< (::xercesc::DOMElement& e, const lennardJones_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Epsilon
  //
  if (i.Epsilon ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Epsilon",
        e));

    a << ::xml_schema::as_double(*i.Epsilon ());
  }

  // Sigma
  //
  if (i.Sigma ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Sigma",
        e));

    a << *i.Sigma ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const forceCalculation_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Gravity
  //
  if (i.Gravity ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Gravity",
        e));

    s << *i.Gravity ();
  }

  // LennardJones
  //
  if (i.LennardJones ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LennardJones",
        e));

    s << *i.LennardJones ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const positionCalculation_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const positionCalculation_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const positionCalculation_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const velocityCalculation_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const velocityCalculation_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const velocityCalculation_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const boundaryBehavior_t& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const boundaryBehavior_t& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const boundaryBehavior_t& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const boundaries_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // BoxSize
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BoxSize",
        e));

    s << i.BoxSize ();
  }

  // Front
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Front",
        e));

    s << i.Front ();
  }

  // Rear
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Rear",
        e));

    s << i.Rear ();
  }

  // Left
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Left",
        e));

    s << i.Left ();
  }

  // Right
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Right",
        e));

    s << i.Right ();
  }

  // Top
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Top",
        e));

    s << i.Top ();
  }

  // Bottom
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Bottom",
        e));

    s << i.Bottom ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const linkedCell_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // BoundaryBox
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BoundaryBox",
        e));

    s << i.BoundaryBox ();
  }

  // CutoffRadius
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "CutoffRadius",
        e));

    s << i.CutoffRadius ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const naive_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMAttr&, const naive_t&)
{
}

void
operator<< (::xml_schema::list_stream&,
            const naive_t&)
{
}

void
operator<< (::xercesc::DOMElement& e, const simulationStrategy_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // LinkedCell
  //
  if (i.LinkedCell ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LinkedCell",
        e));

    s << *i.LinkedCell ();
  }

  // Naive
  //
  if (i.Naive ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Naive",
        e));

    s << *i.Naive ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const logLevel_t& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const logLevel_t& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const logLevel_t& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const fileBenchmark_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);
}

void
operator<< (::xercesc::DOMAttr&, const fileBenchmark_t&)
{
}

void
operator<< (::xml_schema::list_stream&,
            const fileBenchmark_t&)
{
}

void
operator<< (::xercesc::DOMElement& e, const defaultBenchmark_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // MaximumBodySize
  //
  if (i.MaximumBodySize ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "MaximumBodySize",
        e));

    a << *i.MaximumBodySize ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const benchmarkType_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // FileBenchmark
  //
  if (i.FileBenchmark ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "FileBenchmark",
        e));

    s << *i.FileBenchmark ();
  }

  // DefaultBenchmark
  //
  if (i.DefaultBenchmark ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DefaultBenchmark",
        e));

    s << *i.DefaultBenchmark ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const benchmark_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // BenchmarkType
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "BenchmarkType",
        e));

    s << i.BenchmarkType ();
  }

  // IterationCount
  //
  if (i.IterationCount ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "IterationCount",
        e));

    s << *i.IterationCount ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const dimension_t& i)
{
  e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const dimension_t& i)
{
  a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const dimension_t& i)
{
  l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type >& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const particle_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }

  // Velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity",
        e));

    s << i.Velocity ();
  }

  // Mass
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Mass",
        e));

    a << ::xml_schema::as_double(i.Mass ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const cuboid_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }

  // Velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity",
        e));

    s << i.Velocity ();
  }

  // Dimensions
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dimensions",
        e));

    s << i.Dimensions ();
  }

  // Spacing
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Spacing",
        e));

    a << ::xml_schema::as_double(i.Spacing ());
  }

  // Mass
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Mass",
        e));

    a << ::xml_schema::as_double(i.Mass ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const sphere_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Position
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Position",
        e));

    s << i.Position ();
  }

  // Velocity
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Velocity",
        e));

    s << i.Velocity ();
  }

  // Radius
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Radius",
        e));

    a << i.Radius ();
  }

  // Spacing
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Spacing",
        e));

    a << ::xml_schema::as_double(i.Spacing ());
  }

  // Mass
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Mass",
        e));

    a << ::xml_schema::as_double(i.Mass ());
  }
}

void
operator<< (::xercesc::DOMElement& e, const shape_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Particle
  //
  if (i.Particle ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Particle",
        e));

    s << *i.Particle ();
  }

  // Cuboid
  //
  if (i.Cuboid ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Cuboid",
        e));

    s << *i.Cuboid ();
  }

  // Sphere
  //
  if (i.Sphere ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Sphere",
        e));

    s << *i.Sphere ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const shapeList_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Shape
  //
  for (shapeList_t::Shape_const_iterator
       b (i.Shape ().begin ()), n (i.Shape ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Shape",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const simulation_t& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // OutputFile
  //
  if (i.OutputFile ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OutputFile",
        e));

    s << *i.OutputFile ();
  }

  // StartTime
  //
  if (i.StartTime ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "StartTime",
        e));

    s << ::xml_schema::as_double(*i.StartTime ());
  }

  // EndTime
  //
  if (i.EndTime ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "EndTime",
        e));

    s << ::xml_schema::as_double(*i.EndTime ());
  }

  // TimeStepSize
  //
  if (i.TimeStepSize ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "TimeStepSize",
        e));

    s << *i.TimeStepSize ();
  }

  // ForceCalculation
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ForceCalculation",
        e));

    s << i.ForceCalculation ();
  }

  // PositionCalculation
  //
  if (i.PositionCalculation ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "PositionCalculation",
        e));

    s << *i.PositionCalculation ();
  }

  // VelocityCalculation
  //
  if (i.VelocityCalculation ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "VelocityCalculation",
        e));

    s << *i.VelocityCalculation ();
  }

  // AverageBrownianMotion
  //
  if (i.AverageBrownianMotion ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AverageBrownianMotion",
        e));

    s << *i.AverageBrownianMotion ();
  }

  // SimulationStrategy
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SimulationStrategy",
        e));

    s << i.SimulationStrategy ();
  }

  // Dimensions
  //
  if (i.Dimensions ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Dimensions",
        e));

    s << *i.Dimensions ();
  }

  // LogLevel
  //
  if (i.LogLevel ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "LogLevel",
        e));

    s << *i.LogLevel ();
  }

  // Benchmark
  //
  if (i.Benchmark ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Benchmark",
        e));

    s << *i.Benchmark ();
  }

  // ShapeList
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ShapeList",
        e));

    s << i.ShapeList ();
  }
}

void
Simulation (::std::ostream& o,
            const ::simulation_t& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Simulation (::std::ostream& o,
            const ::simulation_t& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Simulation (::std::ostream& o,
            const ::simulation_t& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Simulation (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Simulation (::xercesc::XMLFormatTarget& t,
            const ::simulation_t& s,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Simulation (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
Simulation (::xercesc::XMLFormatTarget& t,
            const ::simulation_t& s,
            ::xml_schema::error_handler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Simulation (::xercesc::XMLFormatTarget& t,
            const ::simulation_t& s,
            ::xercesc::DOMErrorHandler& h,
            const ::xml_schema::namespace_infomap& m,
            const ::std::string& e,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::Simulation (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
Simulation (::xercesc::DOMDocument& d,
            const ::simulation_t& s,
            ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "Simulation" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "Simulation",
      "");
  }
}

::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument >
Simulation (const ::simulation_t& s,
            const ::xml_schema::namespace_infomap& m,
            ::xml_schema::flags f)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "Simulation",
      "",
      m, f));

  ::Simulation (*d, s, f);
  return d;
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

